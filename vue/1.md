- vue 全局注册组件的方法 Vue.component
- 组件避免data引用赋值，使用function ruturn 的方法
- 全局api
- 实例方法以及属性，例如 $on
- 内置组件 <component></component>
- 更改使用 赋值 语句更改data中的某一项，视图不会直接更改，使用Vue.set()方法可以
- 引入子组件(ES6 语法下)
```javascript
// 假设当前是在主组件文件下
import childComp1 from './components/childComp1';
import childComp2 from './components/childComp2';
export default = {
    // 这是一种 ES6 的简写方式
    components: { childComp1, childComp2 }

    // 实际上相当于
    components: { 
        childComp1: = 'childComp1', 
        childComp2: = 'childComp2'
    }
// 最后通过标签的形式在主组件中引入子组件
}
```
- v-bind绑定的属性可以同步更新，简写 `:title="..."`
- class的绑定方法,下面例子将仅显示类名 `red-font`
``` html
<!-- 单一绑定 -->
<div :class="className1"><div>
<!-- 多个变量绑定 -->
<div :class="[className1, className2]"><div>
<!-- 混用 -->
<div :class="[className1, {'error': hasErr}]"><div>
<!-- 行内样式 -->
<div :class="linkCss"><div>
<script>
    // 省略部分代码
------------------------------------------
    // 仅显示类名 `red-font1`、`red-font2`、`hasErr`
    data() {
        return {
            className1: {
                red-font1: true,
                blue-font1: false
            }
            className2: {
                red-font2: true,
                blue-font2: false
            },
            hasErr: true,
            linkCss: {
                'color': 'red',
                'font-size': '20px'
            }
        }
    }
------------------------------------------
    // 显示 `red-font1`、`blue-font1`、`red-font2`、`blue-font2`、
    data() {
        return {
            className1: ['red-font1', 'blue-font1']，
            className1: ['red-font2', 'blue-font2']，
            hasErr: false,
            linkCss: {
                'color': 'red',
                'font-size': '20px'
            }
        }
    }
<script>
```
- 条件判断 v-if、v-else 与 v-show
- 事件操作 v-on,简写为 @,**事件修改器**见下例子
```html
<!-- 阻止冒泡 -->
<button @click.stop="toggle"></button>
<!-- keydown的修改器,这里可以使用key code，例如13-->
<button@keydown.enter="doSomething"></button>
```
- 自定义事件，可以用于父子组件之间的数据传递
- 表单的数据绑定是通过 v-model 绑定的
``` html
<!-- 勾选后会自动填充 data 中的myBox数组 -->
<input v-model="mtBox" type="radio" value="apple"/>
<input v-model="mtBox" type="radio" value="banana"/>
<input v-model="mtBox" type="radio" value"panaple"/>

<script>
    // 省略部分代码
    data() {
        return: {
            // !!! 注意这里必须实现定义声明 myBox，不然会报错，此处声明了myBox的初始值是一个空数组
            myBox: [];
        }
    }
</script>
```
- v-model控制select
``` html
<select v-model="selection">
    <option value="1"></option>
    <option value="2"></option>
    <option value="3"></option>
</select>
<span>{{ selection }}</span>

<script>
    // 省略部分代码
    data() {
        return: {
            // !!! 同样，此处声明了selection的初始值是null
            selection: null;
        }
    }
</script>
---------------------------------------------
// 当然可以通过动态循环的形式初始化每一个option
<select v-model="selection">
    // 注意这里必须使用 :value 也就是bind的形式, 否则解析出的value仅仅是一堆字符串
    <option v-for="item in selectOption" :value="item.value">
        {{item.name}}        
    </option>
</select>
<span>{{ selection }}</span>

<script>
    // 省略部分代码
    data() {
        return: {
            selectOption: [
                {name: 'apple', value: 0},
                {name: 'banana', value: 1},
                {name: 'pinaple', value: 2}
            ],
            selection: null;
        }
    }
</script>
```
- v-model 支持三种修改器
> v-model.lazy
> 
> 
```html
输入完成之后 失焦或者enter，双向绑定的值才会动态更新
<div id="app">
	// 执行失焦或者enter操作完成视图渲染
    <input type="text" v-model.lazy="lazy">
    <span>{{lazy}}</span><br>
    // 输入的值为数值
    <input type="text" v-model.number="number">
    <span>{{typeof number}}</span><br>
    // 去除字符首尾的空格
    <input type="text" v-model.trim="trim">
    <span>{{trim}}</span><br>
    // 当然三者可以连用，like：
    <input type="text" v-model.trim.lazy.number="trim">
    <span>{{trim}}</span><br>
</div>
    

<script>
    const app = new Vue({
        el: '#app',
        data: {
            lazy: null,
            number: null,
            trim: null
        }
    });
</script>
```

- 计算属性与事件调用
> 计算属性与事件调用往往能达到相同的效果，但是他们本质的区别在于：  
>1、计算属性是会被缓存的，他只会根据我们被调用的属性来进行更新  
>2、而方法调用则在每次调用的时候都重新获取一次值  
>3、比如二者return的都是 Date.now();前者显示的是页面渲染初期的时间，而后者则是显示时间被调用时候的时间
```html
<div id="app">
    <p>其实这里绑定的value，但是通过计算属性，使得myValueWithoutNum也能动态更新</p>
    <input type="text" v-model="myValue"/>
    <span>
        {{myValueComputed}}<br>
        {{myValueWithoutNum}}<br>
        {{myValueMethod()}}
    </span>
    <hr> 
</div>

<script>
    var app = new Vue({
        el: '#app',
        data: {
            myValue: ''
        },
        computed: {
            myValueWithoutNum() {
                return this.myValue.replace(/\d/g, '');
            },
            myValueComputed() {
                return this.myValue + 'end'
            }
        },
        methods: {
            myValueMethod() {
                return this.myValue.replace(/\d/g, '');
            }
        }
        
    });
</script>
```

- 属性监听 watch
> 注意：函数参数为 function(新， 旧) {}  
> 应用场景：比如用户想要实现，每次修改（增删改。。。）v-for 出来的list都执行一个方法 tellUser();这时候就可以将数据list watch起来，调用 tellUser 方法即可
```html
<div id="app">
    <p>结合lazy使用会有更好的效果哦~~~</p>
    <input type="text" v-model="myValue">
</div>
<script>
    var app = new Vue({
        el: '#app',
        data: {
            myValue: ''
        },
        watch: {
            myValue: function(val, oldVal) {
                console.log(val, oldVal);
            }
        }
    });
</script>
```
- 组件相关tips
>* 项目只会初始化一个Vue实例
>* 每个组件通过export的形式输出，import的形式引入
>* 引入新的组件之后需要注册组件，通过component: {}
>* 组件引入的命名可以是ComA，调用的时候最好写成<com-a>,vue会自动解析大小写以及‘-’，Vue2.0 写成<ComA>也不会报错
>* 
- 通过:is动态引入组件，注意：组件必须全部提前声明
```html
<div>
    <p is="someValue"></p>
    <p :is="someValue"></p>
</div>

import ComA from './components/com-a'
import ComB from './components/com-b'
components: {
    ComA,
    ComB
},
data: {
    // 这里可以更改 someValue: 'com-b' 的值达到动态引入组件
    someValue: 'com-a'
}
```
- 父子组件之间的通信 视频第四章8:30
>* 父组件向子组件
>* 子组件向父组件
>* 插槽<slot></slot>传递模板,插槽可以设定默认值