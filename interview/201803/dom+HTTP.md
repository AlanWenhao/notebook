# DOM相关

## 目录
- DOM
  - DOM 事件级别
  - DOM 事件模型(冒泡、捕获)
  - DOM 事件流
  - 描述 DOM 事件捕获的具体流程
  - Event 对象的常见应用
  - 自定义事件
- HTTP协议问题
  - 主要特点
  - 报文组成部分
  - HTTP方法
  - POST和GET区别
  - HTTP状态码
  - 什么是持久链接
  - 什么是管线化

### DOM 事件级别( DOM 标准定义的级别)
1. DOM0
```
element.onclick = function() {}
```

1. DOM2,(DOM1 标准也是有的，但是没有定义事件相关的东西)
```
element.addEventListner('click', function(){}, false)
```

1. DOM3(定义了更多的事件)
```
element.addEventListner('keyup', function(){}, false)
```

### DOM 事件模型(捕获、冒泡)

### DOM 事件流
1. 第一阶段：捕获
1. 第二阶段：目标阶段(找到了目标对象)
1. 第三阶段：冒泡

### 设置事件在捕获或冒泡阶段触发
```js
xxx.addEventListner('test', function() {}, false);
// 浏览器默认false，以为在事件冒泡阶段触发，设置true即可在不好阶段触发
```

### 自定义事件
```js
var ev = new Event('test');
xxx.addEventListner('test', function() {}, false);

```

## HTTP
### HTTP主要特点
- 简单快速，统一资源符，想访问一个资源只要输入相应的uri即可
- 灵活，一个HTTP协议可以完成多种数据类型的传输，可以设置header
- 无连接，链接一次会断掉
- 无状态，服务端但从连接上是不能区分多次连接，连接者的身份

### HTTP报文
请求报文：`请求行`、`请求头`、`空行`、`请求体`  
相应报文：`状态行`、`相应头`、`空行`、`响应体`  

### HTTP方法
GET、POST、PUT、DELETE、HEAD(获得报文首部)

### GET与POST的区别
- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET产生的URL地址可以被收藏，而POST不可以
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置
- GET请求只能进行url编码，而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史记录中，而POST中的参数不会被保留
- GET请求在URL中传送的参数是有长度限制的，而POST没有
- GET只接受ASCII字符，而POST没有限制
- GET比POST更不安全，因为参数直接暴露子啊url上，所以不能用来传递敏感信息
- GET参数通过URL传递，POST参数在REqust body中

### HTTP状态码
- 1xx：知识信息-表示请求已接收，继续处理
- 2xx：成功-表示请求已被成功接受
- 3xx：重定向-要完成请求必须进行更进一步的操作
- 4xx：客户端错误-请求有语法错误或者请求无法实现
- 5xx：服务器错误-服务器未能实现合法的请求

### 常见状态码
- 200：OK 客户端请求成功
- 206Partial Content 客户端发送了一个带有Range头的GET请请求，服务器完成了它
- 301 Moved Permanently 所请求的页面已经转移至新的url
- 302 Not Found 所请求的页面已经临时转移至新的url
- 304 Not Modified 客户端有缓冲的文档发出了一个条件性的请求，服务器告诉老客户，原来缓冲的文档还可以继续使用
- 400 Bad Request 客户端有请求有语法错误，不能被服务器所理解
- 401 Unauthorized 请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
- 403 Forbidden 对被请求页面的禁止被访问
- 404 Not Found 请求资源不存在
- 500 Internal Server Error 服务器发生不可预期的错误，原来缓冲的文档还可以继续使用
- 503 Server Unavailable 请求未完成，服务器临时过载或宕机，一段时间后才能恢复

### 持久链接
HTTP协议采用“请求-应答”模式，当使用普通模式即非Keep-Alive模式时，每个请求/应答，客户和服务器都要建立一个链接，完成之后立即断开连接(HTTP协议“无连接”的协议)  
当使用Keep-Alive模式(又称为持久连接、连接重用)时，Keep-Alive功能是客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。  

### 管线化
在使用持久连接的情况下，猴哥连接上的消息传递类似于：  
请求1 > 相应1 > 请求2 > 响应2 > 请求3 > 响应3

管线化就是在这个基础上打包的意思，那么请求与响应就变成了：  
请求1、请求2、请求3 > 响应1、响应2、响应3

管线化的特点：
- 通过持久链接完成的，仅HTTP/1.1支持
- 只有GET和HEAD请求可以进行管线化，POST是不支持的
- 初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP1.1
- 管线化不会影响响应到来的顺序，如上面的例子，响应返回的顺序并没有改变
- 开启管线化可能并不会带来的大幅度的性能提升，而且很多服务器和代理程序并不支持管线化，因此现代浏览器Chrome与FireFox默认不开启管线化
