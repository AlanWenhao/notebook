# 备忘录

## 19-04-22
- 压缩目录可以先使用 tar 在使用 gzip 或 bz2 格式，也可以直接使用 -zcvf 或 -jcvf 压缩
- df -h 查看磁盘分区使用状况
    - 磁盘信息很有用，之后写 shell 脚本查看磁盘使用率的时候回用到
- 如何挂载一块新的硬盘，新建硬盘 => fdisk工具 => w 写入 => mkfs.ext3 /dev/sdb1 格式化 => mount挂载
    - MBR（旧）分区，也可以使用GPT（新）分区
    - 硬盘扇区
    - 理解linux的一切皆文件
    - vim + /etc/fstab 查看分区表，也可以直接修改，但是一旦出错整个系统就会崩溃
- free 命令查看磁盘使用状况
- 添加交换分区，相当于虚拟分区
- vimtutor vim编辑器的教程
- vi + a.txt 定位到最后一行；vi +2 a.txt 打开并定位到第二行
- 用户和用户组实操
    - 每增加一个用户，就会增加一个默认的用户组，组名与用户名一样，还会分配一个新的文件夹作为家目录放在`/home`下
    - `cat /etc/group | grep groupname` 来查看组信息
    - 通过`usermod`修改用户名与用户对用的工作目录
    - 给用户设置密码`password username`
    - 主要组和附属组
- `userdel username` 删除用户后，用户家目录不会别删除，而使用`userdel -d username` 删除则会一并删除

## 19-4-23
- 权限的更改 `chmod [选项] 模式 文件名`
    - 选项 `-R` 递归
    - 模式 [ugoa] u：所有者，g：所有组，o：其他人，a：全部包括ugo
    - +：增加权限，-：减去权限
    - rwx：读写执行
    - 但是这样要求操作者知道原来的权限，才能加或者减
- `chmod 764 1.txt`
    - 这种方式不不用考虑原来的权限
- 文件的最高权限是 `x`
    - 因为一个文件的可以读写最多也意味着是一个记事本，但是文件如果是可执行的，里面的文字可能会带来危险操作，所以文件默认的可执行权限都是没有的
    - 目录的最高权限是 `w`，只有读权限没有意义，对目录有了写权限，里面可以做任何事情，对于目录而言，`x`权限决定进入，`w`权限决定是否能在文件夹内新建删除文件

- umask 掩码，默认是 `022`
    - 创建文件默认权限最大是666，减去022变为644
    - 创建目录默认权限最大是777，减去022变为755
    - 修改掩码`umask 033`，那么这之后对饮的文件权限应该是633，但是发现还是644，是因为，这里的减法是各位转化为二进制之后，进行按位减的（不借位，0-1=0）
    - 为了验证上述掩码是生效的，可以`umask 044`发现，这时候新建的文件或者目录，权限发生了改变
    - 为什么在掩码运算的时候要，0-1=0呢？原因在于，掩码的作用是掩掉某个权限，如果某个权限本身就是0了，即使掩掉也应该还是0

- ACL 这里回看视频（任务58）中一般权限模型不能实现的前提，所以用ACL
    - 手动把某个文件，或者文件夹的权限单独赋给某个用户或者用户组

## 19-4-24
- 别名的设置 alias
- history，命令的历史，文件存放在每个用户家目录 `.bash-history` 
    - `!2`执行历史记录的第二条，`!!`执行历史记录的上一条
- 标准输入输出重定向
- 通过 `set` 打印出的变量，一些是用户自定义的，一些是系统变量
    - echo $PATH 输出的是搜索目录，就是命令存放的目录
    - `set -u` 后访问一个为定义的变量会报错
    - unset 取消变量的绑定
- 环境变量 任务59
    - 可以通过 `export name=Alan` 设置环境变量
    - 可以通过 `name=Ben    export name` 设置环境变量
    - 通过 `pstree` 查看命令的派生状态，执行 `bash` 可以进入子shell（exit退出子shell），子shell中不能读到当前变量，但是可以读到环境变量
    - `env` 打印出来的全部都是环境变量
    - $PATH 是系统搜索路径，比如在 `/alan/shell` 文件夹下有一个 `hello.sh` 文件，那想要通过直接执行 `hello.sh` 就能输出 hello ，需要将 `/alan/shell` 添加到 $PATH, `PATH=$PATH:/alan/shell`
    - 执行文件可以`./sum.sh` 或者 `sh sum.sh` 或者使用环境变量
- $PS1 可以手动修改
- 语系环境变量 $LANG
- 位置参数变量
    - 写一个脚本，`sum.sh 4 6` 输出计算结果，4和6之间可以用空格或tab隔开
    - $() 与 $(()) 的区别，前者里面放的表达式，eg：$(ls) ，后者：$((4+6))，或者可以用 $[]，或者可以用 `$(expr $a + $b)`这里空格必须要有
    - 使用占位符`$n`，n 代表第几个位置
    - 区分 `$*` 和 `$@` 的区别
    - 注意在shell中碰到有$的变量的时候，请使用`""`包裹，不然不出问题
```bash
for i in 1 2 3
do
    echo $i
done
```

- 预定义变量
    - `echo $?` 可以输出上一次命令执行是否成功，0 代表成功，1 代表失败，因为在shell中经常判断上一步是否成功，而决定下一步怎么做
    - `$!` 上一个后台运行进程的 PID

```bash
./sum.sh 3 4 &     # 在后台执行一个脚本文件，

echo $!            # 输出上个后台进程的 PID
# 用处，比如要写一个开机启动nginx的脚本，就需要先启动一次，然后拿到进程号，然后每隔一段时间去检查下，如果进程不存在了，就执行nginx命令重启下
```

```bash
#!/bin/bash
read -p '用户名' -t 10 name
read -p '性别[m/f]' -n 1 gender
echo -e "\n"
read -p '密码' -s password
echo -e "\n"
echo $name $gender $password
```

- 运算符
- declare 手动声明一个变量的类型
    - `declare -i c` 声明c的类型是int
    - `declare +i c` 取消c的int类型声明
    - `declare -x c` 将变量设置为环境变量，`export` 是这个命令的语法糖
    - `declare -p` 输出所有声明的变量，包括用户定义的与系统变量 `declare -p sum` 则是查询sum变量被声明的类型
- 环境变量（任务60），23：00，回看！！！
    - 各个文件有各自的任务，在用户登录后一次执行，比如想要改环境变量path，那就更改 `bash_profile` 文件，因为他负责这个的，其实这几个文件的哪个都行，毕竟都要执行