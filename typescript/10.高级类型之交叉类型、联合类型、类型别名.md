# é«˜çº§ç±»å‹ä¹‹äº¤å‰ç±»å‹ã€è”åˆç±»å‹ã€ç±»å‹åˆ«å
> ä»ç°åœ¨å¼€å§‹è¦æ¥è§¦é«˜çº§ç±»å‹äº†ğŸ˜  

## äº¤å‰ç±»å‹
> äº¤å‰ç±»å‹æ˜¯å°†å¤šä¸ªç±»å‹åˆå¹¶ä¸ºä¸€ä¸ªç±»å‹ï¼Œè¿™è®©æˆ‘ä»¬å¯ä»¥å§ç°æœ‰çš„å¤šç§ç±»å‹å åŠ åˆ°ä¸€èµ·æˆä¸ºä¸€ç§ç±»å‹ï¼Œå®ƒæŠ¥æ¡ˆäº†æ‰€éœ€çš„æ‰€æœ‰ç±»å‹çš„ç‰¹æ€§  

ä¾‹å¦‚JSå¸¸ç”¨çš„ `æ··å…¥æ¨¡å¼` 
```ts
interface IAnyObj {
    [prop: string]: any
}

function mixin<T extends IAnyObj, U extends IAnyObj>(a: T, b: U): T & U {
    const result = <T & U>{};
    for(let key in a) {
        (<T>result)[key] = a[key];
    }
    for(let key in b) {
        (<U>result)[key] = b[key];
    }

    return result;
}

---------------------------------------------------------------------------------------
// æ³›å‹çº¦æŸå£°æ˜å¼å‡½æ•°æ˜¯ function aaa<T> (a: T): T { return a }
// æ³›å‹çº¦æŸå­—é¢é‡å‡½æ•°æ˜¯ const aaa = <T>(a: T) => T = a;
// è¿™é‡Œæ³¨æ„ T æ”¾ç½®çš„ä½ç½®ï¼Œå°±åƒä¸Šé¢ const result = <T & U>{} ä¸€æ ·ï¼Œå­—é¢é‡å½¢å¼çš„æ˜¯å‰ç½®çš„
// è¿˜æœ‰ (<T>result)[key] = a[key] ä¸€æ ·ï¼Œèµ‹å€¼è¯­å¥å·¦è¾¹çš„æ³›å‹çº¦æŸä¹Ÿæ˜¯å‰ç½®çš„
```

## è”åˆç±»å‹
> å¸Œæœ›ä¸€ä¸ªå€¼å±æ€§æ˜¯å¤šç§ç±»å‹ä¹‹ä¸€ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²ä¸æ•°å­—ï¼Œä½¿ç”¨ `|` åˆ†éš”å°±è¡Œäº†

## ç±»å‹åˆ«å
> ç±»å‹åˆ«åä¼šç»™ä¸€ä¸ªç±»å‹èµ·ä¸ªæ–°åå­—ï¼Œç±»å‹åˆ«åæœ‰æ—¶å€™è·Ÿæ¥å£å¾ˆåƒï¼Œä½†æ˜¯å¯ä»¥ä½œç”¨äºåŸå§‹å€¼ã€è”åˆç±»å‹ã€å…ƒç»„ä»¥åŠå…¶ä»–ä»»ä½•ä½ éœ€è¦æ‰‹å†™çš„ç±»å‹  
> å¯ä»¥ä½¿ç”¨ `type SomeName = someValidTypeAnnotation` çš„è¯­æ³•æ¥åˆ›å»ºçˆ±ä½ ç±»å‹åˆ«å  

```ts
type some= boolean | string;
const b: some = true;
const c: some = 'string';
```

ç±»å‹åˆ«åå¯ä»¥æ˜¯æ³›å‹
```ts
type Container<T> = { value: T }
```

å¯ä»¥ä½¿ç”¨ç±»å‹åˆ«ååœ¨å±æ€§é‡Œå¼•ç”¨è‡ªå·±ï¼š
```ts
type Tree<T> = {
    value: T;
    left: Tree<T>;
    right: Tree<T>;
}
```

> `ç±»å‹åˆ«å` è·Ÿ `æ¥å£` å¾ˆåƒï¼Œå¦‚ä½•åŒºåˆ†ä¸¤è€… 

ç›¸åŒç‚¹ï¼š
- éƒ½å¯ä»¥æè¿°ä¸€ä¸ªå¯¹è±¡æˆ–è€…å‡½æ•°
- éƒ½å…è®¸æ‹“å±•
