# 高级类型之交叉类型、联合类型、类型别名
> 从现在开始要接触高级类型了😎  

## 交叉类型
> 交叉类型是将多个类型合并为一个类型，这让我们可以吧现有的多种类型叠加到一起成为一种类型，它报案了所需的所有类型的特性  

例如JS常用的 `混入模式` 
```ts
interface IAnyObj {
    [prop: string]: any
}

function mixin<T extends IAnyObj, U extends IAnyObj>(a: T, b: U): T & U {
    const result = <T & U>{};
    for(let key in a) {
        (<T>result)[key] = a[key];
    }
    for(let key in b) {
        (<U>result)[key] = b[key];
    }

    return result;
}

---------------------------------------------------------------------------------------
// 泛型约束声明式函数是 function aaa<T> (a: T): T { return a }
// 泛型约束字面量函数是 const aaa = <T>(a: T) => T = a;
// 这里注意 T 放置的位置，就像上面 const result = <T & U>{} 一样，字面量形式的是前置的
// 还有 (<T>result)[key] = a[key] 一样，赋值语句左边的泛型约束也是前置的
```

## 联合类型
> 希望一个值属性是多种类型之一，比如字符串与数字，使用 `|` 分隔就行了

## 类型别名
> 类型别名会给一个类型起个新名字，类型别名有时候跟接口很像，但是可以作用于原始值、联合类型、元组以及其他任何你需要手写的类型  
> 可以使用 `type SomeName = someValidTypeAnnotation` 的语法来创建爱你类型别名  

```ts
type some= boolean | string;
const b: some = true;
const c: some = 'string';
```

类型别名可以是泛型
```ts
type Container<T> = { value: T }
```

可以使用类型别名在属性里引用自己：
```ts
type Tree<T> = {
    value: T;
    left: Tree<T>;
    right: Tree<T>;
}
```

> `类型别名` 跟 `接口` 很像，如何区分两者 

相同点：
- 都可以描述一个对象或者函数
- 都允许拓展
