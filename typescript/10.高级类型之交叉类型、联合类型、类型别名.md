# é«˜çº§ç±»å‹ä¹‹äº¤å‰ç±»å‹ã€è”åˆç±»å‹ã€ç±»å‹åˆ«å
> ä»ç°åœ¨å¼€å§‹è¦æ¥è§¦é«˜çº§ç±»å‹äº†ğŸ˜  

## äº¤å‰ç±»å‹
> äº¤å‰ç±»å‹æ˜¯å°†å¤šä¸ªç±»å‹åˆå¹¶ä¸ºä¸€ä¸ªç±»å‹ï¼Œè¿™è®©æˆ‘ä»¬å¯ä»¥å§ç°æœ‰çš„å¤šç§ç±»å‹å åŠ åˆ°ä¸€èµ·æˆä¸ºä¸€ç§ç±»å‹ï¼Œå®ƒæŠ¥æ¡ˆäº†æ‰€éœ€çš„æ‰€æœ‰ç±»å‹çš„ç‰¹æ€§  

ä¾‹å¦‚JSå¸¸ç”¨çš„ `æ··å…¥æ¨¡å¼` 
```ts
interface IAnyObj {
    [prop: string]: any
}

function mixin<T extends IAnyObj, U extends IAnyObj>(a: T, b: U): T & U {
    const result = <T & U>{};
    for(let key in a) {
        (<T>result)[key] = a[key];
    }
    for(let key in b) {
        (<U>result)[key] = b[key];
    }

    return result;
}

---------------------------------------------------------------------------------------
// æ³›å‹çº¦æŸå£°æ˜å¼å‡½æ•°æ˜¯ function aaa<T> (a: T): T { return a }
// æ³›å‹çº¦æŸå­—é¢é‡å‡½æ•°æ˜¯ const aaa = <T>(a: T) => T = a;
// è¿™é‡Œæ³¨æ„ T æ”¾ç½®çš„ä½ç½®ï¼Œå°±åƒä¸Šé¢ const result = <T & U>{} ä¸€æ ·ï¼Œå­—é¢é‡å½¢å¼çš„æ˜¯å‰ç½®çš„
// è¿˜æœ‰ (<T>result)[key] = a[key] ä¸€æ ·ï¼Œèµ‹å€¼è¯­å¥å·¦è¾¹çš„æ³›å‹çº¦æŸä¹Ÿæ˜¯å‰ç½®çš„
```

## è”åˆç±»å‹
> å¸Œæœ›ä¸€ä¸ªå€¼å±æ€§æ˜¯å¤šç§ç±»å‹ä¹‹ä¸€ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²ä¸æ•°å­—ï¼Œä½¿ç”¨ `|` åˆ†éš”å°±è¡Œäº†

## ç±»å‹åˆ«å
> ç±»å‹åˆ«åä¼šç»™ä¸€ä¸ªç±»å‹èµ·ä¸ªæ–°åå­—ï¼Œç±»å‹åˆ«åæœ‰æ—¶å€™è·Ÿæ¥å£å¾ˆåƒï¼Œä½†æ˜¯å¯ä»¥ä½œç”¨äºåŸå§‹å€¼ã€è”åˆç±»å‹ã€å…ƒç»„ä»¥åŠå…¶ä»–ä»»ä½•ä½ éœ€è¦æ‰‹å†™çš„ç±»å‹  
> å¯ä»¥ä½¿ç”¨ `type SomeName = someValidTypeAnnotation` çš„è¯­æ³•æ¥åˆ›å»ºçˆ±ä½ ç±»å‹åˆ«å  

```ts
type some= boolean | string;
const b: some = true;
const c: some = 'string';
```

ç±»å‹åˆ«åå¯ä»¥æ˜¯æ³›å‹
```ts
type Container<T> = { value: T }
```

å¯ä»¥ä½¿ç”¨ç±»å‹åˆ«ååœ¨å±æ€§é‡Œå¼•ç”¨è‡ªå·±ï¼š
```ts
type Tree<T> = {
    value: T;
    left: Tree<T>;
    right: Tree<T>;
}
```

> `ç±»å‹åˆ«å` è·Ÿ `æ¥å£` å¾ˆåƒï¼Œå¦‚ä½•åŒºåˆ†ä¸¤è€… 

ç›¸åŒç‚¹ï¼š
- éƒ½å¯ä»¥æè¿°ä¸€ä¸ªå¯¹è±¡æˆ–è€…å‡½æ•°
- éƒ½å…è®¸æ‹“å±•ï¼ˆextendsï¼‰ï¼Œä½†è¯­æ³•ä¸åŒ

interface extends interface
```ts
interface Name {
    name: string;
}
interface User extends Name {
    age: number;
}
```

type extends type
```ts
type Name = {
    name: string;
}
type User = Name & { age: number };
```

interface extends type
```ts
type Name = {
    name: string;
}
interface User extends Name {
    age: number;
}
```

type extends interface
```ts
interface Name {
    name: string;
}
type User = Name & { age: number }
```

- `type` å¯ä»¥è€Œ `interface` ä¸è¡Œ
    - `type` å¯ä»¥å£°æ˜åŸºæœ¬ç±»å‹åˆ«åï¼Œè”åˆç±»å‹ï¼Œå…ƒç»„ç­‰ç±»å‹
    - `type` è¯­å¥ä¸­è¿˜å¯ä»¥ä½¿ç”¨ `typeof` è·å–å®ä¾‹çš„ç±»å‹è¿›è¡Œèµ‹å€¼
    - å…¶ä»–æ“ä½œ

type å¯ä»¥å£°æ˜åŸºæœ¬ç±»å‹åˆ«åï¼Œè”åˆç±»å‹ï¼Œå…ƒç»„ç­‰ç±»å‹
```ts
// åŸºæœ¬ç±»å‹åˆ«å
type Name = string;

// è”åˆç±»å‹
interface Dog {
    wong();
}
interface Cat {
    miao();
}

type Pet = Dot | Cat

// å…·ä½“å®šä¹‰æ•°æ®æ¯ä¸ªä½ç½®çš„ç±»å‹
type PetList = [Dog, Pet];
```

type è¯­å¥ä¸­è¿˜å¯ä»¥ä½¿ç”¨ typeof è·å–å®ä¾‹çš„ ç±»å‹è¿›è¡Œèµ‹å€¼
```ts
// å½“ä½ æƒ³è·å–ä¸€ä¸ªå˜é‡çš„ç±»å‹æ—¶ï¼Œä½¿ç”¨ typeof
let div = document.createElement('div');
type B = typeof div;
```

å…¶ä»–æ“ä½œ
```ts
type StringOrNumber = string | number;
type Text = string | { Text: string };
type NameLookUp = Dictionary<string, Person>;
type Callback<T> = (data: T) => void;
type Pair<T> = [T, T];
type Coordinates = Pair<number>;
type Tree<T> = T | { left: Tree<T>, right: Tree<T> };
```

- `interface` å¯ä»¥è€Œ `type` ä¸è¡Œ

interface èƒ½å¤Ÿå£°æ˜åˆå¹¶

```ts
interface User {
    name: string;
    age: number;
}

interface User {
    sex: string;
}

// æœ€ç»ˆçš„useræ¥å£ä¸º
interface User {
    name: string;
    age: number;
    sex: string;
}
```

æœ€åï¼Œå¦‚æœä¸æ¸…æ¥šä»€ä¹ˆæ—¶å€™ç”¨ `interface` è¿˜æ˜¯ `type`ï¼Œé‚£ä¹ˆèƒ½ç”¨ `interface` çš„æ—¶å€™ç”¨ `interface`ï¼Œä¸èƒ½ç”¨çš„æ—¶å€™ç”¨ `type`
