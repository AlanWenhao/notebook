# 时间复杂度

## 大 O 复杂度表示法
> 算法的执行效率，粗略的讲就是算法代码的执行时间。但是，如何在不运行代码的情况下，用肉眼得到一段代码的执行时间呢？

下面是一段简单代码
```c
int cal(int n) {
    in sum = 0;
    int i = 1;
    for (; i < n; i++) {
        sum = sum + i;
    }
    return sum;
}
```
从CPU的角度来看，这段代码每一行都在执行类似的操作，`读取 - 运算 - 写数据`，尽管每行代码真正对应的执行时间不是相同的，但是我们可以粗略的估计其时间单位都是 `unit_time`。  
在这个假设之上，这段代码的总执行时间是 `1 + 1 + n + n = (2n +2)*unit_time`  
可以看出 **所有代码的执行时间T(n)与每行代码的执行次数成正比**  

----

```c
int cal(int n) {
    int sum = 0;
    int i = 0;
    int j = 0;
    for (; i < n; i ++) {
        j = 1;
        for (; j < n; j ++) {
            sum = sum + i * j;
        }
    }
    return sum;
}
```
这段代码的执行时间是 `(2n²+2n+3)*unit_time`  
以上可以总结为一个公式：
```
T(n) = O(f(n))
```
> `T(n)`表示代码的执行时间，n表示数据规模的大小，`f(n)`表示每行代码的执行次数的总和。公式中的 `O` 表示代码的执行时间与每行代码的执行时间成正比

> 这就是`大O时间复杂度表示法`，实际 `O` 的时间复杂度实际上并不具体代表代码的施行时间，而是表示**代码执行时间随数据规模增长的变化趋势**。简称`时间复杂度`

## 时间复杂度分析
三中方法分析时间复杂度：
1. 只关注循环执行次数最多的一段代码
1. 加法法则：总复杂度等于数量级最大的那段代码的复杂度
1. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

-----

```c
// 只关注循环执行次数最多的一段代码
// 第4、5行代码被执行了 n 此，所以这段代码的复杂度是 O(n)
int cal(int n) {
    in sum = 0;
    int i = 1;
    for (; i < n; i++) {
        sum = sum + i;
    }
    return sum;
}
```

-----

```c
// 加法法则：总复杂度等于数量级最大的那段代码的复杂度
int cal(int n) {
    int sum_1 = 0;
    int p = 1;
    for (; p < 100, ++p) {
        sum_1 = sum_1 + p;
    }

    int sum_2 =0;
    int 1 = 1;
    for (; q < n; ++q) {
        sum_2 = sum_2 + q;
    }

    int sum_3 = 0;
    int i = 1;
    int j = 1;
    for (; i < n; ++i) {
        j = 1;
        for (; j < n; ++j) {
            sum_3 = sum_3 + i + j;
        }
    }

    return sum_1 + sum_2 + sum_3;
}
```
分析：  
1、第一段代码循环执行了100次，是一个常量的执行时间，跟n的规模无关。在这里，即使这段代码n很大，只要是一个跟n无关的数据，`常量`或者`系数`，都是不能左右都是不能左右增长趋势的。所以忽略尽管这些值很大会影响代码的执行时间，但是从概念的角度出发，他表示一个算法执行时间与数据规模增长的**变化趋势**，所以可以忽略。  
2、第二段代码的复杂度是 O(n)，第三段是 O(n²)
3、综合这三段代码，我们取其中两级虽大的就是 O(n²)

-----
```c
// 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
// 复杂度是 O(n²)
int cal(int n) {
    int ret = 0;
    int i = 1;
    for (; i < n; ++i) {
        ret = ret + f(i);
    }
    return ret;
}
int f(int n) {
    int sum = 0;
    int i = 1;
    for (; i < n; ++i) {
        sum = sum + i;
    }
    return sum;
}
```

## 几种常见的时间复杂度分析实例
![时间复杂度实例](./img/1.png)

代码虽然千差万别，但是常见的复杂度量级并不多。  
可以简单分类为：
- 多项式量级
- 非多项式量级，仅有两个，`O(n²)`，`O(n!)`
    - 当数据规模 n 越来越大时，非多项式量级算法的时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法是非常抵消的算法。

### O(1)
> O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。因此，只要代码执行时间不随n的增长而增长，这样的代码复杂度都是O(1)

> 一般情况下，只要代码中不存在循环语句、递归语句、即使有成千上万行代码，时间复杂度都是O(1)

```c
// O(1)
int i = 8;
int j = 9;
int sum = i + j;
```

### O(logn)、O(nlogn)
> 对数时间复杂度很常见，但是也是很难分析的一种

```c
i = 1;
while (i < n) {
    i + i * 2;
}
```
根据前面提到的，第三行诗执行次数最多的，所以分析第三行，变量 `i` 的取值其实是一个等比数列：  
```
2º  2¹  2²  2³ ...  2^k ... 2^x = n

2^x = n

x = log2 n     以2为底n的对数
```
这段代码的复杂度就是 `O(log2 n)`

----

> 那么这段代码的时间复杂度是 O(log3 n)，其实不然  
> 根据换底公式：log3 n = log3 2 * log2 n，即 `常量 * log2 n  
> 所以，复杂度为 O(logn)
```c
i = 1;
while (i < n) {
    i + i * 2;
}
```

----
> O(nlogn)；如果一段代码的时间复杂度是 O(logn)，这段代码循环了n次，时间复杂度就是 O(nlogn)。其也是一种常见的时间复杂度，比如，`归并排序`、`快速排序`。

### O(m+n) 与 O(m*n)
> 代码的复杂度由两个数据的规模来决定  
> 这里由于不确定的量有 m 与 n 不能根据加法法则舍弃一个，所以时间复杂度为 O(m+n)  
> 但是乘法法则依旧使用，当两个未知量级发生嵌套，O(m*n)，代码略

```c
int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i < m; ++1) {
        sum_1 = sum_1 + i;
    }

    int sum_2 = 0;
    int j = 1;
    for (; j < n; ++j) {
        sum_2 = sum_2 + j;
    }
    return sum_1 + sum_2;
}
```
