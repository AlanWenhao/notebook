## webpack 优化
- webpack-ignore-plugin 可以通过正则筛除掉不必要引入的内容，想一想他是怎么实现的
    - 比如引入`moment.js`默认会引入很多的语言包，可以找到对应语言包引入的代码，针对引入路径做一个正则排除
- dllPlugin 对第三方库使用 dllPlugin
    - 首先，dll 文件需要新增一个webpack的配置用于单独配置。使用内置的 webpack.dllPlugin 构建生成 `meanfeast.json` 与 `dll.js`
    - 在 output 的 `library` 可以设置暴露的变量名，`libraryTarget` 可以设置 `var` 或 `commonjs` 等导出方式
    - 其次，启用另一个 webpack 配置文件，告诉 webpack 该使用哪些 json 文件，并打包业务代码
- 使用 Happypack 进行多线程打包
    - module 中 use 这个 loader，`use: 'Happypack/loader?id=jf'`，这里的 id 对应下面 plugins 中 Happypack 的 options id
    - 但是注意，如果项目打包压力不大的话，没必要使用，这样反而会因为分配线程而更加浪费时间
    - 可以给 `css` 与 `js` 分配不同的 id 从而实现 多线程分开打包
- webpack 自带优化
    - 使用 import 语法，在生产环境先，会自动 `treeshaking`
    - scope hosting 作用域提升，生产环境下自动启用。自动去除一些变量，移动省略一些无效声明。直接把 import 引入 变成了在 当前作用域下声明一个对象，直接使用
    - 使用 `optimization: { spilitChunks }` 来分割代码块，可以根据公用代码的大小与使用次数来决定是否进行抽离
- 懒加载
    - 需要使用 `@babel/plugin-syntax-dynamic-import` 插件来支持
    - 实现点击按钮加载资源 `import('./source.js').then(data => { ... })` 这个 ·import` 是 es6草案 中的语法，在webpack中支持使用。其原理为 jsonp 是先动态加载
    - 使用懒加载后，被懒加载的资源将会被单独打包成一个js文件，当页面懒加载触发的时候，使用jsonp将其引入
- 热更新
    - devServer 设置 hot: true
    - 使用热更新插件 `webpack.HotModuleReplacementPlugin`
    - 使用告知哪个模块更新的插件 `webpack.NameModulesPlugin()`
    - 这时候更改了项目代码，浏览器是强制刷新的，而不是热更新，如果使用的是单页应用的话，状态管理每次都会被初始化
    - 需要在主文件中使用 `module.hot.accept()` 来完成 HMR 的实现
- tapble webpack 插件的机制
    - sync 钩子
        - `SyncHook`
        - `SyncBallHook`          同步保险(容断性)钩子，可以决定在前面的钩子之后是否向下，返回 undefined 则继续向下执行，非 `undefined` 则停止执行
        - `SyncWaterfallHook`     上一个任务中函数的返回值会传给下一个
        - `SyncLoopHook`          webpack 中并没有使用到这个钩子，就是将某一个方法循环执行多次
    - Async 钩子
        - `AsyncParallel` 包含: `AsyncParallelHook`、`AsyncParallelBailHook`
        - `AsyncSeries`   包含: AsyncSeriesHook、AsyncSeriesBailHook、AsyncSeriesWarterfallhook
- tapble 原理解析
    - tapble 库中有三种注册的方法：`tap`, `tapAsync(cb)`, `tapPromise`
    - 调用的时候也是三种方法：`call`, `callAsync`, `promise` 调用代表的是事件队列执行完毕
    - 同步，使用`tap` 注册同步事件，`call` 触发事件
        - 举例：`SyncHook`，使用发布订阅的形式，同步执行数组中的函数任务
        - 举例：`SyncBallHook`，执行的原理见上面。其实就是实现了一个发布订阅，把同步的任务放到数组中，执行时候，使用 `do while` 循环判断任务的返回值，判断是否是 `undefined` 来决定是否向下执行
        - 举例：`SyncWaterfallHook` 使用 reduce 依次拿到上一个函数的返回值并传给下一个函数
    - 异步，使用`tapAsync`注册事件，`callAsync`触发事件
        - `AsyncParallel` 异步并行钩子可以使用`callback`的形式或`promise`的形式
        - `AsyncSeries`   异步穿行

- 手写webpack
    - `npm link` 设置自己的命令
    - 拿到webpack的配置文件
    - 拿到入口的路径 `config.entry`
    - `buildMoudule`方法创建模块的依赖关系
        - 拿到当前模块的路径并读出当前模块的内容
    - parse 方法使用 ast 递归解析，拿到依赖关系
        - 使用的模块 `babylon`, `@babel/tranvers`, `@babel/generator`, `@babel/types`
        - 使用 `babylon` 将代码解析成 AST 语法树，然后读取到其中的 require 引用关系，将 require 改成 `__webpack__require__`，然后在将更改后的 AST 变成 code
        - 判断其中如果还有以来关系，则递归解析，并调用上述 `buildModule` 方法创建子模块的依赖关系
    - 发射文件，拼接字符串，拼接成`__webpack__require__`参数传递的是数组，包含各个模块的路径与内容，再写到webpack配置的输出目录
    - 实现 loader
        - loader 就是一个函数，函数接受源码，比如 less-loader，将代码通过less模块进行编译然后 return 出去
        - style-loader 就是创建一个 style 标签
        - 在 webpack 读取模块路径的时候，看下是否能够匹配 module 中 rules 的 test 正则，如果能的话，拿到 use 数组中的loader，把这个loader require进来，传入源码执行，注意递归，从后往前
    - 实现 plugin
        - 使用`tapble`库
        - 每个插件都是一个class，class中有 apply 方法，内部使用tapbel来注册一个事件，在webpack源码中钩子触发的时候，调用这里的事件队列
- loader
    - loader的特点
        - 第一个loader要返回js脚本，因为最终要在webpack中eval
        - 每个loader最好只做单一的一件事情，方便组合
        - 每个laoder都是无状态的，纯函数
    - 自己实现loader的时候，可以使用webpack配置`resolveLoader`，并设置其中的`modules`指定其在项目下查找loader的目录
    - loader的执行顺序分为三种，pre、normal、inline、post，即前、正常、行内、后，可以通过`enforce`指定
    - loader默认是由两部分组成的，分为`pitchLoader`和`normalLoader`
    - babel-laoder的实现
        - 依赖 babel-core @babel/preset-env
- plugin
    - 自定义实现 upload plugin
        - 写一个类，类的 apply 方法中传入 `compiler`
        - 调用方法 `compiler.hooks.afterEmit.tapPromise`中间拿到每个资源 assets 执行异步的上传法法，return出promise.all(每个promise任务)



